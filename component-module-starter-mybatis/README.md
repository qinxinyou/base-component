
# 1 目的
整合数据库持久层，减少持久层配置以及代码开发。
# 2 内容
## 2.1 规划数据库配置
数据库连接池：druid
数据库配置：DruidStatProperties
## 2.2 整合mybatis-plus
### 2.2.1 mapper默认地址统一配置-启动类不用加@MapperScan
### 2.2.2 启动事务管理
### 2.2.3 注册分页插件
### 2.2.4 自动填充参数
### 2.2.5 主键策略
在复杂分布式系统中，往往需要大量的数据和消息进行唯一标识。比如支付宝每一个账号在数据库分表后都需要有一个唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。
所以，生成的ID需要具备一下特点：
1. 全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。
2. 趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。
3. 单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。
4. 信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。
方案：UUID和SonwFlake
Mybatis-plus中ID上添加@TableId注解，默认主键生成方式是雪花算法+UUID(不含中划线)
#### UUID
UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：550e8400-e29b-41d4-a716-446655440000，到目前为止业界一共有5种方式生成UUID
优点：
* 性能非常高：本地生成，没有网络消耗。
缺点：
* 没有排序，无法保证趋势递增。
* UUID往往使用字符串存储，查询的效率比较低。
* 不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。
* 信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。
* ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用：
* MySQL官方有明确的建议主键要尽量越短越好[4]，36个字符长度的UUID不符合要求。
#### SonwFlake
这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等。
使用41bit作为毫秒数，10bit作为机器的ID(5个bit是数据中心，5个bit的机器ID)，12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生4096个ID），最后还有一个符号位，永远是0。
优点：
* 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
* 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。
* 可以根据自身业务特性分配bit位，非常灵活。
缺点：
* 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。
# 3 依赖整理
依赖名称 | 功能 | 作用域 | 是否向上传递
------ | ---- | ---- | ---- |
`component-dto` | 定义了`DTO`格式，包括分页 | provided| 否 |
`spring-boot-configuration-processor` | 自动配置引擎 | compile | 是 |
`druid-spring-boot-starter` | 数据库连接池 | compile | 是 |
`mybatis-plus-boot-starte` | mybatis持久层框架 | compile | 是 |
`mysql-connector-java` | JDBC数据库连接 | compile | 是 |
`hutool-all` | 工具包 | provided | 否 |
`lombok` | 注解包 | provided | 否 |
# 4 功能